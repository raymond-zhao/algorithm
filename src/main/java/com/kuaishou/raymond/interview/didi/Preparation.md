# 滴滴网约车一面
## 介绍项目
## Redis怎么用的

## 场景题：通过 Redis 存一个配置信息，每日提现金额上限，现在有一亿 QPS 提现请求，怎么解决（本地缓存），
1. 可以选择 string 类型
```json
{
  "daily_withdraw_limit": 1000
}
```
处理一亿 QPS 的提现请求是属于高负载、高并发问题，需要使用多种技术和架构方案来实现。这是典型的高并发设计题，谈到高并发设计有句俗话：“高并发有三宝，缓存、异步、队排好。”所以，我们可以首先围绕这三个技术点加以探讨。
1. 从架构角度，采用分布式架构，将请求负载均衡到多台机器上，实现高可用与水平扩展。
2. 从数据库角度，设计可扩展的主从架构，以便于水平和垂直扩展，另外就是使用数据库分库分表技术，分担单表压力，并且设计合理的数据库表结构与索引，加快查询处理速度。
3. 从缓存角度，使用 Redis 或者 Memcached 缓存，设计可扩展、高可用的 Redis 集群架构，请求时首先从缓存取数据，减少数据库服务器的负载与 TPS。
4. 从异步角度，使用消息队列缓存请求，使用多个消费者异步处理，提高系统吞吐量与性能。
5. 从队列角度，使用如 Kafka 或 RocketMQ 这样支持高并发的消息队列，并且保持请求的有序性与最终一致性。
6. 从代码角度，优化使用到的数据结构与算法，并且使用并发编程、异步I/O，内存池、本地缓存等，并且尽量减少 CPU 和内存的使用。
7. 总之，设计超高并发的系统需要考虑的内容有很多，我们还是需要具体问题具体分析，持续优化与调整，以保证服务的高可用与高性能。
## 更新后怎么刷新本地缓存
采用写后刷新，
## 本地缓存的工具类有哪些？
- HashMap/ConcurrentHashMap 等常见的内存数据结构均可以做本地缓存，但效果有优劣之分。
- Guava Cache：
  - 基于LRU
  - 驱逐策略：by Size、by Weight、by Time
  - Weak Keys, Soft Values
  - 处理 null 值
  - 刷新方式：手动刷新、自动刷新
  - 预加载
  - RemovalNotification
- Caffeine
- Ehcache
## 分布式事务原理
[分布式事务原理](https://draveness.me/distributed-transaction-principle/)
- 分布式事务的实现原理包括事务管理器、事务协议、分布式锁、日志记录和数据同步等多个方面。
名词解释：系统之间的通信可靠性从单一系统中的可靠变成了微服务架构之间的不可靠，分布式事务其实就是在**不可靠的通信下**实现事务的特性。
实现原理：事务日志，无论是需要回滚还是补偿都可以通过日志追溯，而分布式事务也会依赖数据库、Zookeeper 或者 ETCD 等服务追踪事务的执行过程，总而言之，各种形式的日志是保证事务几大特性的重要手段。
直接原因：模块（或服务）之间通信方式的改变
常见类型：2PC、3PC、MySQL 的 XA、SAGA（柔性事务）
- XA
  - XA 实现了 2PC，事务管理器与资源管理器分别充当 2PC 中的事务协调者与事务参与者的身份。
  - MySQL 提供的 XA 接口实现了"投票"与"提交"阶段，当前事务会加锁占用资源，阻塞其他事务对资源的访问，可能会对数据库性能产生影响。
- SAGA
  - 背景：多数场景下只需要最终一致性，而不是强一致性。
  - 流程：Saga 其实就一种简化的分布式事务解决方案，它将一系列的分布式操作转化成了一系列的本地事务，在每一个本地事务中我们都会更新数据库并且向集群中的其他服务发送一条的新的消息来触发下一个本地的事务；一旦本地的事务因为违反了业务逻辑而失败，那么就会立刻触发一系列的回滚操作来撤回之前本地事务造成的副作用。
  - 解释：如果一个 LLT(Long Lived Transaction) 能够被改写成一系列的相互交错重叠的多个数据库事务，那么这个 LLT 就是一个 Saga，数据库系统能够保证 Saga 中一系列的事务要么全部成功执行、要么它们的补偿事务能够回滚全部的副作用，保证整个分布式事务的最终一致性。
  - 类型：协同式Saga(去中心化)、编排式Sage(中心化)。
  - 核心：每一个分布式事务的参与者都需要保证两点，一是提供正常接口与补偿接口，二是接口要允许重入并保证幂等。
  - 特点：放弃了标准的 ACID 事务，选择实现 BASE(Basic Availability, Soft, Eventual consistency) 事务，达到业务上的基本可用性与最终一致性。
  - SAGA 可以满足大多数的业务场景，如果需要强一致性事务，可以选择单机数据源，实现 ACID 事务。
  - 而为了实现 SAGA，我们又经常会用到消息队列，来保证消息的可靠投递。
- 使用消息队列实现分布式事务与使用其他工具实现分布式事务在思想上并没有本质的区别，但是消息队列可以帮我们保证可靠投递、消息持久化、重试等功能。
- 总结：从实现 ACID 事务的 2PC 与 3PC 到实现 BASE 补偿式事务的 Saga，再到最后通过事务消息的方式异步地保证消息最终一定会被消费成功，我们为了增加系统的吞吐量以及可用性逐渐降低了系统对一致性的要求。
## 2PC和3PC区别？
- 2PC（两阶段提交）: 分为 Voting 和 Commit 两个阶段
  - Voting: 协调者（Coordinator）会向事务的参与者（Cohort）询问是否可以执行操作的请求，并等待其他参与者的响应，参与者会执行相对应的事务操作并记录重做和回滚日志，所有执行成功的参与者会向协调者发送 AGREEMENT 或者 ABORT 表示执行操作的结果。
  - Commit: 当所有的参与者都返回了确定的结果（同意或者终止）时，两阶段提交就进入了提交阶段，协调者会根据投票阶段的返回情况向所有的参与者发送提交或者回滚的指令。当事务的所有参与者都决定提交事务时，协调者会向参与者发送 COMMIT 请求，参与者在完成操作并释放资源之后向协调者返回完成消息，协调者在收到所有参与者的完成消息时会结束整个事务；与之相反，当有参与者决定 ABORT 当前事务时，协调者会向事务的参与者发送回滚请求，参与者会根据之前执行操作时的回滚日志对操作进行回滚并向协调者发送完成的消息，在提交阶段，无论当前事务被提交还是回滚，所有的资源都会被释放并且事务也一定会结束。
  - 两阶段提交协议是一个阻塞协议
- 3PC（三阶段提交）: 在 2PC 的基础上引入了**超时机制和准备阶段**，准备阶段的引入其实让事务的参与者有了除回滚之外的其他选择。
## 要你设计一个3PC你要考虑什么问题
- 超时回滚、事务补偿、保证事务最终一致性。
## 慢 SQL 排查过程，表 (a,b,c,d)，索引(c,a,d)，where c=1 and a > 1 and d = 1，where c=1 and a > 1 and d = 1 and d = 2
## 查询优化器的原理
## 算法：手写LRU
# 滴滴网约车二面
## 编程：一个文件，每行格式为"地点 打车人数"，比如"快手 500"，文件很大，有50G。内存限制在128M。输入一个地点，如何快速找出地址对应的打车人数？
对于这个问题，由于内存限制非常小，因此不能直接将整个文件加载到内存中。下面介绍两种解决方案：

使用数据库
可以使用一些流行的关系型数据库，如 MySQL、PostgreSQL 等来处理这个问题。将文件中的每一行作为数据库中的一条记录，其中地点作为一个字段，打车人数作为另一个字段。
对于查询，可以使用 SQL 语句来快速找出指定地点对应的打车人数。由于关系型数据库通常具有优秀的索引和查询优化技术，因此可以快速地处理大量数据，并在较短时间内返回结果。

使用外部排序算法
外部排序算法是一种用于排序和处理大量数据的算法，其基本思想是将大文件分成若干个小文件，然后对这些小文件进行排序，并将它们合并成一个有序的文件。
在这个问题中，可以将原始文件分成若干个小文件，每个小文件包含一定数量的记录。然后，对于每个小文件，可以使用快速排序或归并排序等算法进行排序。
当所有小文件都排序完成后，可以使用归并排序等算法将它们合并成一个有序的文件。在这个过程中，可以将同一地点的记录合并到一起，以便查询时更加高效。
最后，对于查询，可以使用二分查找等算法在有序的文件中快速找出指定地点对应的打车人数。
```java
```


